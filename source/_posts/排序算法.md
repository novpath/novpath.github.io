---
title: 排序算法
toc: true
tags:
  - 排序
  - 代码
  - C
  - C++
categories:
  - 代码
  - 算法
sticky: false
mermaid: false
math: false
date: 2021-02-07 21:51:29
---

## 1.冒泡排序(BubbleSort)

```c++
#include<stdio.h>
#include<stdlib.h>

void swap(int *a, int *b){          //简易交换函数 
	int temp = *a;
	*a = *b;
	*b = temp;
} 

void BubbleSort(int A[], int n){   //从小到大的冒泡排序，最坏时间复杂度O(N^2)，最好时间复杂度O(N)，稳定 
	bool flag;                     //本趟冒泡排序是否发生交换的标志
	for(int i = 0; i < n-1; i++){  //至多n-1趟即可完成排序 
		flag = false;              //初始默认未交换 
		for(int j = n-1; j > i; j--){
			if(A[j-1] > A[j]){     //若为逆序则交换 
				swap(&A[j-1], &A[j]);
				flag = true;
			}                      
			if(flag = false){      
				return ;           //本轮未发生交换则直接判定为表已经有序 
			}
		}
    }
}

int main(){
	int A[] = {1, 4, 2, 5, 0 ,3, 6};    //测试样例 
	int lenth = sizeof(A)/sizeof(A[0]); //判断表长 
	BubbleSort(A, lenth);               //调用BubbleSort算法 
	for(int i = 0; i < lenth; i++){     //打印表 
		printf("A[%d] = %d\n", i, A[i]);
	}
	return 0;
}
```

## 2.简单选择排序(SelectSort)

```c++
#include<stdio.h>
#include<stdlib.h>

void swap(int *a, int *b){              //简易交换函数 
	int temp = *a;
	*a = *b;
	*b = temp;
} 

void SelectSort(int A[], int n){       //从小到大的选择排序，时间复杂度恒为O(N^2)，不稳定 
	for(int i = 0; i < n-1; i++){      //至多n-1趟(0≤i <n-1)即可完成排序,表中仅有一个元素时不会进入循环 
		int min = i;                   //记录该趟排序最小值的下标(位置)
		for(int j = i+1; j < n; j++){
			if(A[j] < A[min]){         //将比较结果小者的下标值记录在k中 
				min = j;
			}
		}
		if(min != i){                  //min值改变才需要交换
			swap(&A[min], &A[i]);      //从前往后，每趟归位好一个最小值 
		}
    }
}

int main(){
	int A[] = {1, 4, 2, 5, 0 ,3, 6};    //测试样例 
	int lenth = sizeof(A)/sizeof(A[0]); //判断表长 
	SelectSort(A, lenth);               //调用SlectSort算法 
	for(int i = 0; i < lenth; i++){     //打印表 
		printf("A[%d] = %d\n", i, A[i]);
	}
	return 0;
}
```

## 3.插入排序(InsertSort)

```c++
#include<stdio.h>
#include<stdlib.h>

void swap(int *a, int *b){              //简易交换函数 
	int temp = *a;
	*a = *b;
	*b = temp;
} 

void InsertSort(int A[], int n){       //从小到大的直接插入排序，最坏时间复杂度恒为O(N^2)，最好时间复杂度O(N)，稳定 
	int i, j;
	for(i = 1; i < n; i++){            //进行n-1趟排序，将A[1]~A[n-1]插入到前面已排序序列
	    if(A[i] < A[i-1]){             //待排元素小于前面已有序序列，则需要插入排序 
	    	int boundary = A[i];       //复制为哨兵，boundary仅用于防止越界不存储元素
	    	int temp = A[i];           //temp临时存放A[i]
	    	for(j = i; boundary < A[j-1]; j--){   //j从后往前开始比较已有序部分 
                A[j] = A[j - 1];    //将A[j-1]后移一位至A[j] 
			}
			A[j] = temp;    //插入位置为j 
		}
	}
}

int main(){
	int A[] = {1, 4, 2, 5, 0 ,3, 6};    //测试样例 
	int lenth = sizeof(A)/sizeof(A[0]); //判断表长 
	InsertSort(A, lenth);               //调用InsertSort算法 
	for(int i = 0; i < lenth; i++){     //打印表 
		printf("A[%d] = %d\n", i, A[i]);
	}
	return 0;
}
```

## 4.归并排序(MergeSort)

```c++
#include<stdio.h>
#include<stdlib.h>

int *B = (int *)malloc((10)*sizeof(int));

void Merge(int A[], int low, int mid, int high){
	int k, i, j;
	
	for(k = low; k <= high; k++){
		B[k] = A[k];
	}
	for(i = low, j = mid+1, k = i; i <= mid && j <= high; k++){
		if(B[i] <= B[j]){
			A[k] = B[i++];
		}else{
			A[k] = B[j++];
		}
	}//for
	while(i <= mid)
	    A[k++] = B[i++];
	while(j <= high)
	    A[k++] = B[j++];
}

void MergeSort(int A[], int low, int high){
	if(low < high){
		int mid = (low + high)/2;
		MergeSort(A, low, mid);
		MergeSort(A, mid+1, high);
		Merge(A, low, mid, high);
	}//if
}

int main(){
	int A[] = {1, 4, 2, 5, 0 ,3, 6};    //测试样例 
	int lenth = sizeof(A)/sizeof(A[0]); //判断表长
	MergeSort(A, 0, lenth-1);           //调用MergeSort算法 
	for(int i = 0; i < lenth; i++){     //打印表 
		printf("A[%d] = %d\n", i, A[i]);
	}
	return 0;
}
```